// scala面向对象

1. 封装

scala当中属性默认是public的,其底层实现已经是private,之后使用get和set方法对其进行读写。
所以scala不推荐用户在自己将属性私有化，自己去写get和set方法了。

特殊点： 为了能够和java框架进行兼容 对照 -》 scala提供了@BeanProperty 注解注释单条属性为javaBean的格式 


属性访问权限：  private 私有的 -》  伴生类及伴生对象之中 
			   protected 受保护的 -》 保护范围在 自身类及其子类
			   默认 -》 就是public访问权限
			   private[包名] -》 包访问权限 括号当中只能写自身的包名最后一个

2. 继承

scala当中也是单继承多实现的 ：如果没有父类只有特质， 第一个特质仍然是extends关键字  
							如果有父类，必须先继承父类 之后再实现特质

scala当中子类可以继承父类和特质的所有属性和方法，包含抽象和非抽象的val和var属性，及抽象和非抽象的方法

子类可以去重写抽象的属性var和val，以及非抽象的属性val，var的属性不能重写，可以直接拿来修改使用。方法都是可以重写的。

属性可以重写的原理： 因为属性底层就是通过底层的get和set方法来进行读写的，重写属性本质上还是重写方法

继承的时候可以出现冲突的情况：
1. 不同的父类和特质之间有相同的抽象属性和方法 -》 对应实现抽象属性和方法即可 ，本质上不造成冲突
2. 不同的父类和特质之间有相同的非抽象属性和方法 -》 如果不重写 子类无法识别使用谁的，会报错 所以必须重写 



3. 多态
父类的引用指向子类的实例 

调用属性 -》 如果子类重写了，调用子类的属性，如果没有重写，调用父类的属性 
调用方法 -》 如果子类重写了，调用子类的方法，如果没有重写，调用父类的方法 


和java的多态性质不同，java中属性不存在重写的说法，如果多态调用属性的话，调用的属性取决于指针指向的位置，一般是父类的属性
